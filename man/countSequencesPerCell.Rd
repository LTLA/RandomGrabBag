% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/countSequencesPerCell.R
\name{countSequencesPerCell}
\alias{countSequencesPerCell}
\title{Count sequences per cell}
\usage{
countSequencesPerCell(x, filter.field = NULL, filter.value = NULL)
}
\arguments{
\item{x}{A \linkS4class{SplitDataFrameList} where each \linkS4class{DataFrame} is a cell and each row is a sequence.}

\item{filter.field}{Character vector specifying the columns on which to filter sequences prior to counting.}

\item{filter.value}{Character vector of length equal to \code{filter.field},
specifying the values to retain for each filter field.}
}
\value{
An integer scalar containing the number of (filtered) sequences per cell.
}
\description{
Count the number of sequences per cell, possibly after filtering.
}
\details{
The number of sequences per cell is often a useful diagnostic.
At its simplest, we can use it to determine whether a particular cell contributes to the immune repertoire at all,
e.g., to verify clusters that are B or T cells.

A more complex use case is to identify cells that express multiple sequences.
This is generally a minority occurrence due to allelic exclusion in most cells (see also \code{\link{topCoveragePropPerCell}})
but can be inflated by technical artifacts such as doublets or contamination from ambient noise.

The filtering enables us to perform more complex diagnostics,
e.g., count the number of productive, full-length, high-quality sequences in each cell.
}
\examples{
df <- data.frame(
    cell.id=sample(LETTERS, 30, replace=TRUE),
    v_gene=sample(c("TRAV1", "TRAV2", "TRAV3"), 30, replace=TRUE),
    j_gene=sample(c("TRAJ4", "TRAJ5", "TRAV6"), 30, replace=TRUE),
    productive=sample(c("True", "False"), 30, replace=TRUE)
)

y <- splitDataFrameByCell(df, field="cell.id")
countSequencesPerCell(y)
countSequencesPerCell(y, filter.field="productive", filter.value="True")

}
\author{
Aaron Lun
}
