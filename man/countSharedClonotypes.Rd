% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/countSharedClonotypes.R
\name{countSharedClonotypes}
\alias{countSharedClonotypes}
\alias{countSharedClonotypes,ANY-method}
\alias{countSharedClonotypes,CompressedSplitDataFrameList-method}
\title{Count shared clonotypes across groups}
\usage{
countSharedClonotypes(x, ...)

\S4method{countSharedClonotypes}{ANY}(
  x,
  clone.field,
  group,
  metric = c("none", "jaccard", "maximum"),
  collapse.cells = FALSE
)

\S4method{countSharedClonotypes}{CompressedSplitDataFrameList}(x, clone.field, cov.field, group, ...)
}
\arguments{
\item{x}{Any data.frame-like object where each row corresponds to a single cell and contains its representative sequence.
Rows with any \code{NA} values in the specified \code{clone.field} columns are ignored.

Alternatively, a \linkS4class{SplitDataFrameList} where each \linkS4class{DataFrame} corresponds to a cell 
and each row in that DataFrame is a sequence in that cell.}

\item{...}{For the generic, further arguments to pass to individual methods.

For the \code{CompressedSplitDataFrameList} method, further arguments to pass to the ANY method.}

\item{clone.field}{String specifying the columns of \code{x} containing the clonotype identity.}

\item{group}{Factor of length equal to \code{x} indicating the group to which each cell belongs.}

\item{metric}{String specifying the type of sharing metric to return.}

\item{collapse.cells}{Logical scalar indicating whether each clonotype should be counted only once.}

\item{cov.field}{String specifying the column of \code{x} containing the read/UMI coverage.}
}
\value{
A numeric matrix where the off-diagonal entries contain metrics of clonotype sharing between each pair of groups.
}
\description{
Count the number of clonotypes that are shared across groups, usually different cell types.
}
\details{
This function quantifies the sharing of clonotypes are shared across different groups.
The most obvious application is to identify shared clonotypes across different cell types (as represented by cluster identity),
allowing us to infer that those cell types shared a common ancestor.
Examples include clonotypes that are shared across various B or T cell states (e.g., activation, memory),
indicating that there is an active transition between states. 

If \code{metric="none"}, we return the number of clonotypes that are shared between each pair of groups.
If \code{collapse.cells=FALSE}, we instead return the total number of cells across both groups that exhibit a shared clonotype.

If \code{metric="jaccard"}, the Jaccard index is computed between every pair of groups.
On a practical level, this adjusts for differences in the size of the groups so that large groups do not dominate the output.
On a theoretical level, we interpret this value by considering the progenitor population that gives rise to the two groups;
the Jaccard index represents the proportion of cells in the progenitor population that can develop into either group.
If \code{collapse.cells=FALSE}, a weighted version of the Jaccard index is used, i.e., the Ruzicka similarity.
This involves summing the minimum and maximum frequencies of each clonotype in the numerator and denominator, respectively.

If \code{metric="maximum"}, we compute the larger of the proportions of shared clonotypes across the two groups.
For example, if 10 clonotypes are shared and one group has 20 clonotypes and the other group has 40 clonotypes,
the output value will be 0.5.
This is designed to detect high shared proportions in smaller groups;
for example, if a rare subpopulation is derived from the same progenitors as a much larger population,
the Jaccard index would be small even if the sharing in the small subpopulation is very high.
If \code{collapse.cells=FALSE}, we instead compute the proportion of cells in each group that exhibit a shared clonotype.
}
\examples{
df <- data.frame(
    cell.id=sample(LETTERS, 30, replace=TRUE),
    clonotype=sample(paste0("clonotype_", 1:5), 30, replace=TRUE),
    umi=pmax(1, rpois(30, 5))
)

y <- splitDataFrameByCell(df, field="cell.id")
out <- countSharedClonotypes(y, "clonotype", cov.field="umi",
   group=sample(3, length(y), replace=TRUE))
out

}
\seealso{
\code{\link{countCellsPerClonotype}}, to compare between groups.
}
\author{
Aaron Lun
}
